<!DOCTYPE html>
<html>
	<head>
		<title>HackenEdit</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/>
	</head>
<body>
	<svg width="100%" height="85vh" style="background-color:rgb(188, 224, 248)"></svg>

<script src="https://d3js.org/d3.v5.min.js"></script>
<!-- <script src="d3.v4.min.js"></script> -->
<script>
	var width = .9*window.innerWidth
//	var height = window.screen.availHeight;//.innerHeight
	var height = .75*window.innerHeight
	var ground = .95*height;
	const nodeRadius = 8;

	var svg = d3.select('svg');
//  svg.attr('width', width);
//	svg.attr('height', height);
    svg.on('click', clickOnCanvas)

	let color = 0;
	var links = [];
	let linkId = 0;
//	link(0, 1, 'red');
	let nId = 0;
	var nodes = [];

	// let nId = numbers.length;
	// let count = 1;
	// for(i=0; i<count; i++){
	// 	n = nId++;
	// 	console.log('add', n)
	// 	numbers.push(n);
	// 	link(1, n, 'blue')
	// }

function link(from, to, color){
	// avoid cycles and duplicate links
	if(isSameRoot(from, to)) {
//		console.log(`Block linking ${from.id} and ${to.id} to avoid cycles`);
		return;
	}
	onLink(from, to);
	const link = {id: ++linkId, source: from, target: to, color: color || 'blue'};
	links.push(link);
	return link;
}

// n1, n2

// n1 is junction with a neighbour n2
// n2 has path which has a depth 

// path 12 root n1

// link n1 n3 

// n1 has two neighbours n2 and n3
// p12 p13 => p213

//let paths = []
// const newNode = (i) => {
// 	id: i;
// 	pathIdentity: null;
// 	neighbours: []; // sorted array starting with the top depth neighbours
// }

function getRoot(i) {
	let root = i.pathIdentity;
	while(root?.parent) root = root.parent;
	return root;
}

function isSameRoot(i, j) {
	const r = getRoot(i);
	return r && r === getRoot(j);
}

function onLink(i, j) {
	if(!i.pathIdentity && !j.pathIdentity){
		newPath(i, j, "new");
		return;
	}
	if(i.pathIdentity && !j.pathIdentity ){
		// check if i is the terminal of its path
		if(i.pathIdentity.terminals.includes(i.id)){
			j.pathIdentity = i.pathIdentity;
			i.pathIdentity.terminals = i.pathIdentity.terminals.map(t => t == i.id ? j.id : t);
		}
		else {
			newPath(i,j, "branch");
		}
		return;
	}
	if(j.pathIdentity && !i.pathIdentity ){
		// check if j is the terminal of its path
		if(j.pathIdentity.terminals.includes(j.id)){
			i.pathIdentity = j.pathIdentity;
			j.pathIdentity.terminals = j.pathIdentity.terminals.map(t => t == j.id ? i.id : t);
		}
		else {
			newPath(j,i, "branch");
		}
		return;
	}
	if(i.pathIdentity && j.pathIdentity){
		newPath(i,j, "merge");
		return;
	}
	restructure(i);
}

function restructure(i) {
}

// here i and j are node ids
function initPath(i, j, depth) {
	const path = {
		parent: null,
		depth: depth || 0,
		terminals: [i, j]
	}
	return path;
}

// here i and j are nodes
const ptostr = (p) => p ? `${p.terminals[0]}-${p.terminals[1]}/${p.depth}` : 'empty path';

// here i and j are nodes
function newPath(i, j, operation) {
	const path = {
		depth: 0,
		terminals: [i.id, j.id]
	}
	switch (operation) {
		case "new":
			i.pathIdentity = path;
			j.pathIdentity = path;
			path.parent = null;
			break;
		case "branch":
			j.pathIdentity = path;
			path.parent = i.pathIdentity;
			let p = path; 
			while(p.parent){

				// decide if the parent should be restructured
				const [p1, p2] = splitPathAtNode(p.parent, p.terminals[0]);
				const [primary, secondary] = p2.depth > p1.depth ? [p2, p1] : [p1, p2];
//				console.log('prim', ptostr(primary), 'sec', ptostr(secondary));
				if(secondary.depth < p.depth){
					// combine p and primary: p will be extended to include primary
					p.terminals[0] = primary.terminals[0];
					if(!p.parent.parent)p.depth = Math.max(p.depth, primary.depth);
					// reassign primary's nodes and children to p
					primary.terminals.forEach(n => setNodePath(n, p));
					primary.insideNodes.forEach(n => n.pathIdentity = p);
					delete primary.insideNodes;
					primary.children.forEach(c => c.parent = p);
					delete primary.children;
					
					// make secondary a child of combined path
					secondary.parent = p;
					secondary.terminals.reverse();

					// reassign pathIdentity to secondary
					nodes.find(n => n.id === secondary.terminals[1]).pathIdentity = secondary; 
					secondary.insideNodes.forEach(n => n.pathIdentity = secondary);
					delete secondary.insideNodes;
					secondary.children.forEach(c => c.parent = secondary);
					delete secondary.children;
					
					if(!p.parent.parent) {
						p.parent = null;
						break;
					}

					// attach the restructured path to the next parent
					setNodePath(p.terminals[0], p.parent.parent);
					p.parent = p.parent.parent;

				}
				else {
					if(p.parent.depth === p.depth)
						p.parent.depth += 1;
				}
				p = p.parent;
			}
			break;
		case "merge":

			break;
		default:
			break;

	}
}
function setNodePath(nodeId, path){
	const node = nodes.find(n => n.id === nodeId);
	if(node){
		console.log(`set node ${node.id} path from ${ptostr(node.pathIdentity)} to ${ptostr(path)}...`);
		node.pathIdentity = path;
	}
	else console.error(`node ${nodeId} not found`); 
} 

const splitAt = (path, node) => {
	// if(node.pathIdentity !== path){
	// 	console.error(`Split blocked: node ${node.id} is not part of the path`);
	// 	return;
	// }

	// visit
}

const addToPaths = (i, j) => {

	if (paths.length() == 0) 
	{
		paths.push(newPath(i,j));
		return;
	}

	let pathToFuse = null;
	let maxDepth = 0;
	const neighbourPathsAtSource = paths.filter(p => pathHasNode(p, i));
	if (neighbourPathsAtSource.length() == 0) {
		for (const path in neighbourPathsAtSource) {
			if(path.depth > maxDepth){
				
			}
		}
	}

	// choose the 2 deepest neighbour path and fuse them

	const neighbourPathsAtTarget = paths.filter(p => pathHasNode(p, j))
}

//	const neighbours = links.find(link => link.source == i || link.target == j)

let visited = {}
let neighbours = {}

function initConnections(){
	neighbours = {}
	links.forEach(link => {
		if(!neighbours[link.source.id]) neighbours[link.source.id] = [];
		if(!neighbours[link.target.id]) neighbours[link.target.id] = [];
		neighbours[link.target.id].push(link.source.id);
		neighbours[link.source.id].push(link.target.id);
	});
}
function visitConnected(nodeId){
	visited[nodeId] = true;
	if(neighbours[nodeId])
		neighbours[nodeId].forEach(id => {if(!visited[id]) visitConnected(id)});
}

function initPathTraversal(path){
	const neighbours = {}
	// for all links touching given path (path links or direct children)
	// .filter(link.source.pathIdentity === path || link.target.pathIdentity === path )
	const relevant = links.filter(link => link.source.pathIdentity === path || link.target.pathIdentity === path );
//	console.log(relevant);
	relevant.forEach(link => {
		if(!neighbours[link.source.id]) neighbours[link.source.id] = [];
		if(!neighbours[link.target.id]) neighbours[link.target.id] = [];
		neighbours[link.target.id].push(link.source);
		neighbours[link.source.id].push(link.target);
	});
	return {path, neighbours, visited:{}, depth:0, children: []};
}

function explorePathToJunction(state, nodeId, junctionNodeId){
	if(nodeId === junctionNodeId) return;
	const {path, neighbours, visited} = state;
	visited[nodeId] = true;

	if(neighbours[nodeId])
		neighbours[nodeId].forEach(node => {
			// is the link is part of the path or starting a child path
			if(node.pathIdentity === path) {
				if(!visited[node.id]) explorePathToJunction(state, node.id, junctionNodeId)
			}
			else {	// this node belongs to a child path, update depth and append to the childrend list
				if(node.pathIdentity.depth >= state.depth){
					state.depth = node.pathIdentity.depth + 1;
				}
				state.children.push(node.pathIdentity);
			}
		});	
}

function getPathFromTerminalToInternal(state, terminal, internal){
	state.depth = 0;
	state.visited = {};
	state.children = [];
	explorePathToJunction(state, terminal, internal);
	const path = initPath(terminal, internal, state.depth);
	path.insideNodes = nodes.filter(n => n.id != terminal && state.visited[n.id]);
	path.children = state.children;
	return path;
}

function splitPathAtNode(path, nodeId){
	const state = initPathTraversal(path);
	const parts = path.terminals.map(t => getPathFromTerminalToInternal(state, t, nodeId));
	if(path.parent?.depth > parts[0].depth){
		parts[0].depth = path.parent.depth;
	}

//	console.log('split at', nodeId, ...parts.map(p => ptostr(p)));
	return parts;
}

function makeNode(n) {
	console.log('makeNode', n);
	return {
		id: n,
	};
}

var linkElements, nodeElements, textElements;

// we use svg groups to logically group the elements together
var baseGroup = svg.append('g').attr('class', 'base')
var linkGroup = svg.append('g').attr('class', 'branch')
var nodeGroup = svg.append('g').attr('class', 'node')
var textGroup = svg.append('g').attr('class', 'texts')

// select node is called on every click

function onNodeClick(node) {
	d3.event?.stopPropagation();
	console.log(node.id, ptostr(node.pathIdentity));
	selectNode(node);
	if(node.isSelected)connectSelected(node);
	else highlightPath(node);
	updateSimulation();
}

function connectSelected(node) {
	const selection = nodes.filter(n => n.isSelected);
	if(selection.length > 1)
	{
		link(selection[0], selection[1]);
		selection
//			.filter(n => n.id != node.id)
			.forEach(n => selectNode(n))
	}
}

function selectNode(selectedNode) {
//	console.log('selectNode', selectedNode.id);
	selectedNode.isSelected = !selectedNode.isSelected;
//	colorNode(selectedNode, selectedNode.isSelected ? 'yellow' : null);
//	fixNode(selectedNode, selectedNode.isSelected);

//	console.log('before', nodes);
//	addNodeAt(selectedNode)
}
function fixNodePath(node) {
	if(node.pathIdentity){
		const related = links.filter(x => x.source === node || x.target === node);
		switch(related.length){
			case 0:
				node.pathIdentity = null;break;
			case 1: 
				if(related[0].source === node) 
					node.pathIdentity = related[0].target.pathIdentity;
				if(related[0].target === node) 
					node.pathIdentity = related[0].source.pathIdentity;
			break;
			default:
				related.forEach(x => { 
					if(x.source === node && node.pathIdentity.depth < x.target.pathIdentity.depth) 
						node.pathIdentity = x.target.pathIdentity;
					if(x.target === node && node.pathIdentity.depth < x.source.pathIdentity.depth) 
						node.pathIdentity = x.target.pathIdentity;
				});
				break;
		}
	}
}
function fixNode(node, on = true) {
	if(on) {
		node.fx = node.x;
		node.fy = node.y;
	} 
	else {
		delete node.fx;
		delete node.fy;
	}
}

function removeBranch(branch) {
	// TODO: update pathIdentity
	
	console.log("remove branch", branch);
	links.splice(links.indexOf(branch), 1);

	fixNodePath(branch.source);
	fixNodePath(branch.target);

	// now remove branches/nodes that are no longer supported
//	links = links.filter(x => visited[x.source.id]);
//	console.log(links);
//	console.log(nodes);
//	nodes = nodes.filter(x => links.some(l => l.source === x || l.target === x) );
//	nodes = nodes.filter(x => visited[x.id]);
	updateSimulation();
}

function onClickBranch(branch) {
	d3.event.stopPropagation();
	console.log(branch.source.id, branch.target.id);
	console.log(branch.source.pathIdentity.depth, branch.target.pathIdentity.depth);
	console.log(branch.source.pathIdentity, branch.target.pathIdentity);
//	colorBranch(branch);
}

function colorBranch(branch) {
//	console.log('color', branch.color);
	branch.color = branch.color == 'red' ? 'blue' :
		branch.color == 'blue' ? 'green' :
		'red';
	d3.select(`#b${branch.id}`)
		.attr('stroke', branch.color)
}

function colorNode(node, newColor) {
	var color = newColor || 'lightgrey';
	d3.select(`#n${node.id}`)
		.attr('fill', color)
		.attr('stroke', newColor || 'grey')
		.attr('r', newColor ? nodeRadius+3 : nodeRadius)
}

function addNodeAt(existingNode) {
	const newNode = addNode(existingNode.x, existingNode.y + 5*nodeRadius);
	return link(existingNode, newNode, 'green');
}

function clickOnCanvas(e, z, b) {
//	console.log('clickOnCanvas', e, z, b);
	let node = addNode(d3.event?.x, d3.event?.y);
	selectNode(node);
	connectSelected(node);
	updateSimulation();
}

function highlightPath(node){
	const path = node?.pathIdentity;
	console.log(ptostr(path));
	pathNodes = nodes.filter(n => n.pathIdentity === path);
	console.log(pathNodes.map(n=>n.id));
	pathNodes.forEach(selectNode
//		n => n.isSelected = true
	);
}

function addNode(x, y) {
//	console.log('addNode', x, y);
	const fixed = x && y;
	var newId = ++nId;
	x = x || d3.event?.x || width/2;
	y = y || d3.event?.y || height/2;
//	console.log('add', newId, 'at', x, y);
	const newNode = makeNode(newId);
	newNode.x = x;
	newNode.y = y;
	if(fixed) fixNode(newNode);
 	nodes.push(newNode);
	return newNode;
}

function updateGraph(nodes) {
//   groundLine = baseGroup.selectAll('line').data([0])
//   .enter().append('line')
//     .attr('stroke-width', 5)
//     .attr('stroke', 'brown')
// 	.attr('x1', 0).attr('y1', ground)
// 	.attr('x2', "100%").attr('y2', ground)
// 	.on('click', addBase)

  // links
  linkElements = linkGroup.selectAll('line')
    .data(links, x => x.id)
  // set correct color on load	
  linkElements.attr('stroke', x => x.color || 'red')

  linkElements.exit().transition()
    .duration(333)//.attr('y1', height).attr('y2', height)
    .style('opacity', 0).remove()

  var linkEnter = linkElements.enter()
  	.append('line').attr("id", d => 'b'+d.id)
    .attr('stroke-width', 6)
    .attr('stroke', x => x.color || 'red')
	.on('dblclick', removeBranch)
	.on('click', onClickBranch)

  linkElements = linkEnter.merge(linkElements)

  // nodes
  nodeElements = nodeGroup.selectAll('circle')
    .data(nodes, function (node) { return node.id })
	.attr('fill', n => 'lightgrey')

  nodeElements.exit().transition()
    .duration(333).attr('cy', height)
    .style('opacity', 0).remove()
  
  var nodeEnter = nodeElements
    .enter().append('circle')
    .attr('stroke',  n => n.isSelected ? 'yellow' : 'grey')
	.attr("id", n => 'n' + n.id)
    .attr('r', nodeRadius)
    .attr('fill', 'lightgrey')
    .call(dragDrop)
    // call method on every click
    .on('click', onNodeClick)

  	nodeElements = nodeEnter.merge(nodeElements)

  // texts
 textElements = textGroup.selectAll('text')
   .data(nodes, function (node) { return node.id })

 textElements.exit().remove()

  var textEnter = textElements
    .enter().append('text')
    .text(function (node) { return node.id })
    .attr('font-size', 10)
    .attr('dx', 1.5*nodeRadius)
    .attr('dy', .5*nodeRadius)

  textElements = textEnter.merge(textElements)
}

// simulation setup with all forces
var linkForce = d3.forceLink()
  .id(function (link) { return link.id })
  .distance(10*nodeRadius)
  .strength(function (link) { return 1; })

var simulation = d3.forceSimulation().force('link', linkForce)
	// force along horizontal direction
	.force('x', d3.forceX().strength(.01).x( width/2 ))
	// force along vertical direction
	.force('y', d3.forceY().strength(.01).y(height/2))
	//.force('center', d3.forceCenter(width/2, height/2))

.force('repel', d3.forceManyBody().strength(-10)) // repel
.force('collision', d3.forceCollide().radius(nodeRadius)); // keep distance

//console.log(`alpha ${simulation.alpha()}`)

var toNode = null;
const distanceSquared = (x, y, node) => (node.x - x)**2 + (node.y - y)**2;

var dragDrop = d3.drag().on('start', function (node) {
//	d3.select(this).classed("fixed", node.fixed = false);
//  node.fx = node.x
//  node.fy = node.y
}).on('drag', function (node) {
  const event = d3.event;
  node.fx = event.x
  node.fy = event.y
  var distance = event.y - ground
  const delta = 2*nodeRadius
//  var close = distance < delta && distance > -delta
//  if(close) makeBase(node);
//  else makeRegular(node);
//  colorNode(node);// colored again later 

  let delta2 = delta**2;
  let oldToNode = toNode;
  toNode = nodes.find(x => x.id != node.id && distanceSquared(event.x, event.y, x) < delta2);
  if(oldToNode)
  {
	fixNode(oldToNode, false);
  }
  if(toNode)
  {
	fixNode(toNode);
  }
  colorNode(node, toNode ? 'yellow' : null);
  updateSimulation();
  //simulation.alphaTarget(0.7).restart()
}).on('end', function (node) {
	simulation.stop();
	if(toNode)
	{
		glue(node, toNode);
		toNode = null;
	} 
//	if (!d3.event.active) {
//		simulation.alphaTarget(0.7)
//	}
// make this node back to floating instead of fixed position
//  node.fx = null
//  node.fy = null
})

const glue = (node, toNode) => {
	console.log('glue', node.id, toNode.id);
	links.forEach(x => {
		if(x.source === node) x.source = toNode;
		if(x.target === node) x.target = toNode;
	});
	toNode.fx = toNode.x;
	toNode.fy = toNode.y;

	nodes.splice(nodes.indexOf(node), 1);
	updateSimulation();
}

function updateSimulation() {

  updateGraph(nodes)

  simulation.nodes(nodes)
  .on('tick', () => {
    nodeElements
      .attr('cx', function (node) { return node.x })
      .attr('cy', function (node) { return node.y })
      .attr('stroke', (n) => n.isSelected ? 'yellow' : 'grey');
    textElements
      .attr('x', function (node) { return node.x })
      .attr('y', function (node) { return node.y });
    linkElements
      .attr('x1', function (link) { return link.source.x })
      .attr('y1', function (link) { return link.source.y })
      .attr('x2', function (link) { return link.target.x })
      .attr('y2', function (link) { return link.target.y })
      .attr('stroke', getColor);
  })

  simulation.force('link').links(links)
  simulation.alphaTarget(0.9).restart()
}

const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple', 
	'lightblue', 'teal', 'cyan', 'magenta', 'pink', 'lightgrey', 'darkgrey'];
const getColor = (link) => colors[(linkDepth(link)||0) % colors.length];
const linkDepth = (link) => Math.min(link.source.pathIdentity?.depth, link.target.pathIdentity?.depth);
// trigger the initial render
let node = addNode();
let branch = addNodeAt(node);
//selectNode(branch.target);
let branch2 = addNodeAt(branch.target);
fixNode(branch2.target, false);

const n = 2;
for(let i=0; i<n; i++){
	branch = addNodeAt(branch.target);
}
selectNode(branch.source);

// making table
// for(let i=0; i<n; i++){
// 	branch = addNodeAt(branch.target);
// }
// makeBase(branch.target);

updateSimulation()

	// d3.select('#button').on('click', function(d) {
	// 	addBase();
//		simulation.alphaTarget(0.7).restart()
//		updateSimulation();
//		color+=1;
//		console.log(color);
//		console.log(nodes.map(x=>x.id));
//		console.log(links.map(x=>x.source.id));
//		console.log(links.map(x=>x.target.id));
//		console.log(links);
//		simulation.stop();
//	});
	const save = ()=>{
	const state = {
		nodes: nodes,
		links: links.map(x=>({...x, source: x.source.id, target: x.target.id}))
	};
	localStorage.setItem('state', JSON.stringify(state));
}
const load = ()=>{
	const saved = localStorage.getItem('state');
	if(!saved) return;

	// nodes = [];
	// links = [];
	// updateSimulation();

	const state = JSON.parse(saved);
	nodes = state.nodes;
	links = state.links;
	console.log(state);
	nId = Math.max(...nodes.map(n=>n.id));
	linkId = Math.max(...links.map(n=>n.id));
	updateSimulation();
//	nodes.forEach(colorNode);
}
</script>
<hr>
<input type="button" value="Save" onclick="save()"/>
<input type="button" value="Load" onclick="load()"/>
</body>
</html>
